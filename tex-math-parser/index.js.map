{"version":3,"file":"index.js","mappings":"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","sources":["webpack://tex-math-parser/webpack/bootstrap","webpack://tex-math-parser/webpack/runtime/define property getters","webpack://tex-math-parser/webpack/runtime/hasOwnProperty shorthand","webpack://tex-math-parser/./src/Token.ts","webpack://tex-math-parser/./src/tokenizeTex.ts","webpack://tex-math-parser/external module \"mathjs\"","webpack://tex-math-parser/./src/customMath.ts","webpack://tex-math-parser/./src/ParseError.ts","webpack://tex-math-parser/./src/parseTokens.ts","webpack://tex-math-parser/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export const lexemeToType = {\r\n    ':': 3 /* Colon */,\r\n    '=': 4 /* Equals */,\r\n    '\\\\ne': 5 /* Notequals */,\r\n    '\\\\neq': 5 /* Notequals */,\r\n    '<': 6 /* Less */,\r\n    '>': 7 /* Greater */,\r\n    '\\\\le': 8 /* Lessequal */,\r\n    '\\\\leq': 8 /* Lessequal */,\r\n    '\\\\ge': 9 /* Greaterequal */,\r\n    '\\\\geq': 9 /* Greaterequal */,\r\n    '+': 10 /* Plus */,\r\n    '-': 11 /* Minus */,\r\n    '*': 12 /* Star */,\r\n    '\\\\cdot': 12 /* Star */,\r\n    '\\\\times': 13 /* Times */,\r\n    '^': 15 /* Caret */,\r\n    _: 16 /* Underscore */,\r\n    '/': 14 /* Slash */,\r\n    ',': 17 /* Comma */,\r\n    '{': 18 /* Lbrace */,\r\n    '}': 19 /* Rbrace */,\r\n    '(': 20 /* Lparen */,\r\n    ')': 21 /* Rparen */,\r\n    '[': 22 /* Lbracket */,\r\n    ']': 23 /* Rbracket */,\r\n    '|': 24 /* Bar */,\r\n    '&': 25 /* Amp */,\r\n    True: 45 /* True */,\r\n    False: 46 /* False */,\r\n    '?': 48 /* Undefined */,\r\n    bmatrix: 52 /* Matrix */,\r\n    '\\\\\\\\': 26 /* Dblbackslash */,\r\n    '\\\\sqrt': 27 /* Sqrt */,\r\n    '\\\\frac': 28 /* Frac */,\r\n    '\\\\sin': 29 /* Sin */,\r\n    '\\\\cos': 30 /* Cos */,\r\n    '\\\\tan': 31 /* Tan */,\r\n    '\\\\csc': 32 /* Csc */,\r\n    '\\\\sec': 33 /* Sec */,\r\n    '\\\\cot': 34 /* Cot */,\r\n    '\\\\arcsin': 35 /* Arcsin */,\r\n    '\\\\arccos': 36 /* Arccos */,\r\n    '\\\\arctan': 37 /* Arctan */,\r\n    '\\\\sinh': 38 /* Sinh */,\r\n    '\\\\cosh': 39 /* Cosh */,\r\n    '\\\\tanh': 40 /* Tanh */,\r\n    '\\\\log': 41 /* Log */,\r\n    '\\\\ln': 42 /* Ln */,\r\n    '\\\\exp': 43 /* Exp */,\r\n    e: 49 /* E */,\r\n    '\\\\mathrm': 44 /* Mathrm */,\r\n    '\\\\mathbf': 47 /* Mathbf */,\r\n    '\\\\begin': 50 /* Begin */,\r\n    '\\\\end': 51 /* End */,\r\n    '\\\\left': 53 /* Left */,\r\n    '\\\\right': 54 /* Right */,\r\n    T: 56 /* T */,\r\n    '\\\\det': 57 /* Det */,\r\n    '\\\\operatorname': 58 /* Opname */,\r\n    eigenvectors: 60 /* Eigenvectors */,\r\n    eigenvalues: 59 /* Eigenvalues */,\r\n    cross: 61 /* Cross */,\r\n    proj: 62 /* Proj */,\r\n    comp: 63 /* Comp */,\r\n    norm: 64 /* Norm */,\r\n    inv: 65 /* Inv */,\r\n};\r\nexport const lexemeToSymbol = {\r\n    // Greek letters\r\n    '\\\\Alpha': 'Alpha',\r\n    '\\\\alpha': 'alpha',\r\n    '\\\\Beta': 'Beta',\r\n    '\\\\beta': 'beta',\r\n    '\\\\Gamma': 'Gamma',\r\n    '\\\\gamma': 'gamma',\r\n    '\\\\Delta': 'Delta',\r\n    '\\\\delta': 'delta',\r\n    '\\\\Epsilon': 'Epsilon',\r\n    '\\\\epsilon': 'epsilon',\r\n    '\\\\varepsilon': 'varepsilon',\r\n    '\\\\Zeta': 'Zeta',\r\n    '\\\\zeta': 'zeta',\r\n    '\\\\Eta': 'Eta',\r\n    '\\\\eta': 'eta',\r\n    '\\\\Theta': 'Theta',\r\n    '\\\\theta': 'theta',\r\n    '\\\\vartheta': 'vartheta',\r\n    '\\\\Iota': 'Iota',\r\n    '\\\\iota': 'iota',\r\n    '\\\\Kappa': 'Kappa',\r\n    '\\\\kappa': 'kappa',\r\n    '\\\\varkappa': 'varkappa',\r\n    '\\\\Lambda': 'Lambda',\r\n    '\\\\lambda': 'lambda',\r\n    '\\\\Mu': 'Mu',\r\n    '\\\\mu': 'mu',\r\n    '\\\\Nu': 'Nu',\r\n    '\\\\nu': 'nu',\r\n    '\\\\Xi': 'Xi',\r\n    '\\\\xi': 'xi',\r\n    '\\\\Omicron': 'Omicron',\r\n    '\\\\omicron': 'omicron',\r\n    '\\\\Pi': 'Pi',\r\n    '\\\\pi': 'pi',\r\n    '\\\\varpi': 'varpi',\r\n    '\\\\Rho': 'Rho',\r\n    '\\\\rho': 'rho',\r\n    '\\\\varrho': 'varrho',\r\n    '\\\\Sigma': 'Sigma',\r\n    '\\\\sigma': 'sigma',\r\n    '\\\\varsigma': 'varsigma',\r\n    '\\\\Tau': 'Tau',\r\n    '\\\\tau': 'tau',\r\n    '\\\\Upsilon': 'Upsilon',\r\n    '\\\\upsilon': 'upsilon',\r\n    '\\\\Phi': 'Phi',\r\n    '\\\\phi': 'phi',\r\n    '\\\\varphi': 'varphi',\r\n    '\\\\Chi': 'Chi',\r\n    '\\\\chi': 'chi',\r\n    '\\\\Psi': 'Psi',\r\n    '\\\\psi': 'psi',\r\n    '\\\\Omega': 'Omega',\r\n    '\\\\omega': 'omega',\r\n    // Comparisons\r\n    '\\\\ne': '!=',\r\n    '\\\\neq': '!=',\r\n    '\\\\le': '<=',\r\n    '\\\\leq': '<=',\r\n    '\\\\ge': '>=',\r\n    '\\\\geq': '>=',\r\n    // Operators\r\n    '\\\\frac': '/',\r\n    '\\\\cdot': '*',\r\n    // Other\r\n    '\\\\i': 'i',\r\n    '\\\\infty': 'Infinity',\r\n    '\\\\lim': 'lim',\r\n};\r\n// TODO: Make conversions consistent with those in mathjs src/utils/latex.js\r\n/**\r\n * A mapping from a token type to the operation it represents.\r\n * The operation is the name of a function in the mathjs namespace,\r\n * or of a function to be defined in scope (i.e. in the argument to math.evaluate())\r\n */\r\nexport const typeToOperation = {\r\n    [4 /* Equals */]: 'equal',\r\n    [5 /* Notequals */]: 'unequal',\r\n    [6 /* Less */]: 'smaller',\r\n    [7 /* Greater */]: 'larger',\r\n    [8 /* Lessequal */]: 'smallerEq',\r\n    [9 /* Greaterequal */]: 'largerEq',\r\n    [10 /* Plus */]: 'add',\r\n    [11 /* Minus */]: 'subtract',\r\n    [12 /* Star */]: 'multiply',\r\n    [13 /* Times */]: 'multiply',\r\n    [15 /* Caret */]: 'pow',\r\n    [14 /* Slash */]: 'divide',\r\n    [28 /* Frac */]: 'divide',\r\n    [24 /* Bar */]: 'abs',\r\n    [27 /* Sqrt */]: 'sqrt',\r\n    [29 /* Sin */]: 'sin',\r\n    [30 /* Cos */]: 'cos',\r\n    [31 /* Tan */]: 'tan',\r\n    [32 /* Csc */]: 'csc',\r\n    [33 /* Sec */]: 'sec',\r\n    [34 /* Cot */]: 'cot',\r\n    [35 /* Arcsin */]: 'asin',\r\n    [36 /* Arccos */]: 'acos',\r\n    [37 /* Arctan */]: 'atan',\r\n    [38 /* Sinh */]: 'sinh',\r\n    [39 /* Cosh */]: 'cosh',\r\n    [40 /* Tanh */]: 'tanh',\r\n    [41 /* Log */]: 'log10',\r\n    [42 /* Ln */]: 'log',\r\n    [43 /* Exp */]: 'exp',\r\n    [57 /* Det */]: 'det',\r\n    [60 /* Eigenvectors */]: 'eigenvectors',\r\n    [59 /* Eigenvalues */]: 'eigenvalues',\r\n    [61 /* Cross */]: 'cross',\r\n    [62 /* Proj */]: 'proj',\r\n    [63 /* Comp */]: 'comp',\r\n    [64 /* Norm */]: 'norm',\r\n    [65 /* Inv */]: 'inv',\r\n};\r\n/**\r\n * A mapping from a token type to the operation it represents for multiple variables.\r\n * The operation is the name of a function in the mathjs namespace,\r\n * or of a function to be defined in scope (i.e. in the argument to math.evaluate())\r\n */\r\nexport const typeToMultivarOperation = {\r\n    [27 /* Sqrt */]: 'nthRoot',\r\n    [41 /* Log */]: 'log',\r\n};\r\nclass Token {\r\n    /**\r\n       * A token in a TeX string.\r\n       * @param {string} lexeme string literal of the token\r\n       * @param {TokenType} type type of the token\r\n       * @param {Number} pos position of the token in the input string\r\n       *\r\n       * @constructor Token\r\n       */\r\n    constructor(lexeme, type, pos) {\r\n        this.lexeme = lexeme;\r\n        this.type = type;\r\n        this.pos = pos;\r\n    }\r\n}\r\nexport default Token;\r\n","import Token, { lexemeToType, lexemeToSymbol } from './Token';\r\nfunction isWhitespace(c) {\r\n    return c.trim() === '';\r\n}\r\nfunction isAlpha(c) {\r\n    return /^[A-Za-z]{1,1}$/.test(c);\r\n}\r\nfunction isControl(c) {\r\n    return /[^ -~]/.test(c);\r\n}\r\nfunction isDigit(c) {\r\n    return c >= '0' && c <= '9';\r\n}\r\n// Returns the next word starting at pos in the string.\r\n// If the string begins with non-alphabetic characters at pos, returns an empty string.\r\nfunction scanWord(str, pos) {\r\n    if (!isAlpha(str[pos])) {\r\n        return '';\r\n    }\r\n    let end = pos;\r\n    // consume characters until a non-alphabetic character is encountered\r\n    while (isAlpha(str[end])) {\r\n        end += 1;\r\n    }\r\n    return str.slice(pos, end);\r\n}\r\n// Returns the next number starting at pos in the string.\r\n// If the string begins with a non-digit at pos, returns an empty string.\r\nfunction scanNumber(str, pos) {\r\n    if (!isDigit(str[pos])) {\r\n        return '';\r\n    }\r\n    let end = pos + 1;\r\n    // consume characters until a non-digit is found\r\n    while (isDigit(str[end])) {\r\n        end += 1;\r\n    }\r\n    if (str[end] === '.') {\r\n        end += 1;\r\n        // decimal number\r\n        while (isDigit(str[end])) {\r\n            end += 1;\r\n        }\r\n    }\r\n    return str.slice(pos, end);\r\n}\r\nclass LexError extends Error {\r\n    constructor(message = '', pos, ...args) {\r\n        super(...args);\r\n        this.name = 'LexError';\r\n        this.message = `at ${pos}: ${message}`;\r\n    }\r\n}\r\n// Convert a TeX string to an array of tokens\r\nexport default function tokenizeTex(texStr) {\r\n    let i = 0;\r\n    const { length } = texStr;\r\n    const tokens = [];\r\n    while (i < length) {\r\n        // skip leading whitespace\r\n        while (isWhitespace(texStr[i])) {\r\n            i += 1;\r\n        }\r\n        let lexeme = '';\r\n        let type = 55 /* Eof */;\r\n        const c = texStr[i];\r\n        // don't accept control characters\r\n        if (isControl(c)) {\r\n            throw new LexError('invalid control sequence encountered '\r\n                + '(forgot to escape backslashes (\\\\begin => \\\\\\\\begin)?)', i);\r\n        }\r\n        // scan for single-char non-alphabetical lexemes\r\n        if (!isAlpha(c) && c in lexemeToType) {\r\n            type = lexemeToType[c];\r\n            lexeme = c;\r\n        }\r\n        else if (c === '\\\\') {\r\n            // scan for multi-char lexemes starting with \\\r\n            const nextChar = texStr[i + 1];\r\n            if (nextChar === '\\\\') {\r\n                // double backslash\r\n                type = 26 /* Dblbackslash */;\r\n                lexeme = '\\\\\\\\';\r\n            }\r\n            else if (nextChar === ' ') {\r\n                // space character: ignore\r\n                type = 66 /* Space */;\r\n                lexeme = '\\\\ ';\r\n            }\r\n            else {\r\n                // TeX command\r\n                const command = scanWord(texStr, i + 1);\r\n                if (command === undefined) {\r\n                    // an alpha char must immediately follow the backslash\r\n                    // or the command is malformed\r\n                    throw new LexError('expected command '\r\n                        + '(a non-alphabetic character was encountered)', i);\r\n                }\r\n                else {\r\n                    lexeme = `\\\\${command}`;\r\n                    type = lexemeToType[lexeme];\r\n                    if (type === undefined && lexeme in lexemeToSymbol) {\r\n                        type = 2 /* Symbol */;\r\n                    }\r\n                    if (type === undefined) {\r\n                        throw new LexError(`unknown command \"${lexeme}\"`, i);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (isDigit(c)) {\r\n            // scan for numbers\r\n            // the position i passed to scanNumber includes the current digit character\r\n            // because the first character is part of the number\r\n            lexeme = scanNumber(texStr, i);\r\n            type = 0 /* Number */;\r\n        }\r\n        else if (isAlpha(c)) {\r\n            // scan for identifiers\r\n            const identifier = scanWord(texStr, i);\r\n            if (identifier in lexemeToType) {\r\n                // identifier is a \"keyword\" (e.g. matrix)\r\n                lexeme = identifier;\r\n                type = lexemeToType[identifier];\r\n            }\r\n            else {\r\n                // identifier has no meaning; interpret as a sequence of single-char lexemes\r\n                const ch = identifier[0];\r\n                if (ch in lexemeToType) {\r\n                    // single-char alphabetical lexeme\r\n                    lexeme = ch;\r\n                    type = lexemeToType[ch];\r\n                }\r\n                else {\r\n                    // unrecognized alphabetical lexeme: treat as variable\r\n                    lexeme = ch;\r\n                    type = 1 /* Variable */;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            throw new LexError(`unrecognized character \"${c}\"`, i);\r\n        }\r\n        // ignore space characters\r\n        if (type !== 66 /* Space */) {\r\n            tokens.push(new Token(lexeme, type, i));\r\n        }\r\n        i += lexeme.length;\r\n    }\r\n    tokens.push(new Token('EOF', 55 /* Eof */, i));\r\n    return tokens;\r\n}\r\n","var x = (y) => {\n\tvar x = {}; __webpack_require__.d(x, y); return x\n} \nvar y = (x) => (() => (x))\nconst __WEBPACK_NAMESPACE_OBJECT__ = x({ [\"all\"]: () => (__WEBPACK_EXTERNAL_MODULE_mathjs__.all), [\"create\"]: () => (__WEBPACK_EXTERNAL_MODULE_mathjs__.create) });","import { create, all } from 'mathjs';\r\n// use BigNumber to reduce floating-point rounding errors\r\nconst math = create(all, {\r\n    number: 'BigNumber',\r\n    precision: 64,\r\n});\r\n// Additional functions to be passed to the scope of math.evaluate(scope)\r\n// (not defined in mathjs)\r\nconst mathImport = {\r\n    lastFn: '',\r\n    lastArgs: [],\r\n    eigenvalues: (matrix) => math.eigs(matrix).values,\r\n    eigenvectors: (matrix) => math.eigs(matrix).vectors,\r\n    comp: (a, b) => math.divide(math.dot(a, b), math.norm(a)),\r\n    proj: (a, b) => math.multiply(math.divide(a, math.norm(a)), math.divide(math.dot(a, b), math.norm(a))), // projection of b along a\r\n};\r\nmath.import(mathImport, {\r\n    override: true,\r\n});\r\n// hacky way to disable unit parsing\r\n// https://github.com/josdejong/mathjs/issues/1220\r\nconst units = math.Unit.UNITS;\r\nObject.keys(units).forEach((unit) => { delete units[unit]; });\r\nexport default math;\r\n","export default class ParseError extends Error {\r\n    constructor(message = '', token, ...args) {\r\n        super(...args);\r\n        this.name = 'ParseError';\r\n        this.message = `${token.lexeme} at ${token.pos}: ${message}`;\r\n    }\r\n}\r\n","import math from './customMath';\r\nimport ParseError from './ParseError';\r\nimport Token, { typeToOperation, lexemeToType, lexemeToSymbol, typeToMultivarOperation, } from './Token';\r\n/**\r\n * Create the corresponding MathJS node of a Token and its children.\r\n * @returns A newly constructed MathJS node.\r\n */\r\nfunction createMathJSNode(token, children = []) {\r\n    var _a, _b;\r\n    let fn = typeToOperation[token.type];\r\n    switch (token.type) {\r\n        case 4 /* Equals */:\r\n            return new math.OperatorNode('==', fn, children);\r\n        case 13 /* Times */:\r\n            return new math.FunctionNode('cross', children);\r\n        case 11 /* Minus */:\r\n            // mathjs differentiates between subtraction and the unary minus\r\n            fn = children.length === 1 ? 'unaryMinus' : fn;\r\n        // falls through\r\n        case 10 /* Plus */:\r\n        case 12 /* Star */:\r\n        case 28 /* Frac */:\r\n        case 14 /* Slash */:\r\n        case 5 /* Notequals */:\r\n        case 6 /* Less */:\r\n        case 8 /* Lessequal */:\r\n        case 7 /* Greater */:\r\n        case 9 /* Greaterequal */:\r\n            return new math.OperatorNode(((_a = lexemeToSymbol[token.lexeme]) !== null && _a !== void 0 ? _a : token.lexeme), fn, children);\r\n        case 15 /* Caret */:\r\n            if (children.length < 2) {\r\n                throw new ParseError('Expected two children for ^ operator', token);\r\n            }\r\n            // manually check for ^T as the transpose operation\r\n            if (math.isSymbolNode(children[1]) && children[1].name === 'T') {\r\n                return new math.FunctionNode('transpose', [children[0]]);\r\n            }\r\n            return new math.OperatorNode(token.lexeme, fn, children);\r\n        case 16 /* Underscore */:\r\n            return new math.AccessorNode(children[0], new math.IndexNode(children.slice(1)));\r\n        // mathjs built-in functions\r\n        case 24 /* Bar */:\r\n        case 27 /* Sqrt */:\r\n        case 29 /* Sin */:\r\n        case 30 /* Cos */:\r\n        case 31 /* Tan */:\r\n        case 32 /* Csc */:\r\n        case 33 /* Sec */:\r\n        case 34 /* Cot */:\r\n        case 38 /* Sinh */:\r\n        case 39 /* Cosh */:\r\n        case 40 /* Tanh */:\r\n        case 35 /* Arcsin */:\r\n        case 36 /* Arccos */:\r\n        case 37 /* Arctan */:\r\n        case 41 /* Log */:\r\n        case 42 /* Ln */:\r\n        case 43 /* Exp */:\r\n        case 59 /* Eigenvalues */:\r\n        case 60 /* Eigenvectors */:\r\n        case 57 /* Det */:\r\n        case 61 /* Cross */:\r\n        case 62 /* Proj */:\r\n        case 63 /* Comp */:\r\n        case 64 /* Norm */:\r\n        case 65 /* Inv */:\r\n            if (children.length > 1) {\r\n                fn = (_b = typeToMultivarOperation[token.type]) !== null && _b !== void 0 ? _b : fn;\r\n            }\r\n            return new math.FunctionNode(fn, children);\r\n        case 58 /* Opname */:\r\n            return new math.FunctionNode(children[0], children.slice(1));\r\n        case 3 /* Colon */:\r\n            return new math.AssignmentNode(children[0], children[1]);\r\n        case 1 /* Variable */:\r\n            return new math.SymbolNode(token.lexeme);\r\n        case 0 /* Number */: {\r\n            // convert string lexeme to number if posssible\r\n            const constant = Number.isNaN(Number(token.lexeme)) ? token.lexeme : +token.lexeme;\r\n            return new math.ConstantNode(constant);\r\n        }\r\n        case 2 /* Symbol */:\r\n            return new math.SymbolNode(lexemeToSymbol[token.lexeme]);\r\n        case 49 /* E */:\r\n            return new math.SymbolNode('e');\r\n        case 45 /* True */:\r\n            return new math.SymbolNode('true');\r\n        case 46 /* False */:\r\n            return new math.SymbolNode('false');\r\n        case 48 /* Undefined */:\r\n            return new math.SymbolNode('undefined');\r\n        case 52 /* Matrix */:\r\n            return new math.ArrayNode(children);\r\n        case 56 /* T */:\r\n            return new math.SymbolNode('T');\r\n        default:\r\n            throw new ParseError('unknown token type', token);\r\n    }\r\n}\r\nfunction createMathJSString(tokens) {\r\n    return new math.SymbolNode(tokens.map((token) => {\r\n        switch (token.type) {\r\n            case 1 /* Variable */:\r\n            case 0 /* Number */:\r\n            case 49 /* E */:\r\n            case 56 /* T */:\r\n            case 59 /* Eigenvalues */:\r\n            case 60 /* Eigenvectors */:\r\n            case 61 /* Cross */:\r\n            case 62 /* Proj */:\r\n            case 64 /* Norm */:\r\n            case 65 /* Inv */:\r\n                return token.lexeme;\r\n            case 2 /* Symbol */:\r\n                return lexemeToSymbol[token.lexeme];\r\n            default:\r\n                throw new ParseError('unknown token type', token);\r\n        }\r\n    }).join(''));\r\n}\r\n// Maps each left grouping token to its corresponding right grouping token\r\nconst rightGrouping = {\r\n    [20 /* Lparen */]: 21 /* Rparen */,\r\n    [18 /* Lbrace */]: 19 /* Rbrace */,\r\n    [22 /* Lbracket */]: 23 /* Rbracket */,\r\n    [53 /* Left */]: 54 /* Right */,\r\n    [24 /* Bar */]: 24 /* Bar */,\r\n};\r\n// Token types that are primaries or denote the start of a primary\r\nconst primaryTypes = [\r\n    53 /* Left */,\r\n    20 /* Lparen */,\r\n    18 /* Lbrace */,\r\n    24 /* Bar */,\r\n    0 /* Number */,\r\n    1 /* Variable */,\r\n    2 /* Symbol */,\r\n    28 /* Frac */,\r\n    27 /* Sqrt */,\r\n    29 /* Sin */,\r\n    30 /* Cos */,\r\n    31 /* Tan */,\r\n    32 /* Csc */,\r\n    33 /* Sec */,\r\n    34 /* Cot */,\r\n    35 /* Arcsin */,\r\n    36 /* Arccos */,\r\n    37 /* Arctan */,\r\n    38 /* Sinh */,\r\n    39 /* Cosh */,\r\n    40 /* Tanh */,\r\n    41 /* Log */,\r\n    42 /* Ln */,\r\n    43 /* Exp */,\r\n    57 /* Det */,\r\n    44 /* Mathrm */,\r\n    47 /* Mathbf */,\r\n    49 /* E */,\r\n    50 /* Begin */,\r\n    56 /* T */,\r\n    58 /* Opname */,\r\n];\r\nclass Parser {\r\n    /**\r\n       * A recursive descent parser for TeX math. The following context-free grammar is used:\r\n       *\r\n       * comp => expr ((EQUALS | NOTEQUALS | LESS | LESSEQUAL | GREATER | GREATEREQUAL) expr)*\r\n       *       | VARIABLE EQUALS EQUALS comp\r\n       *\r\n       * expr => term ((PLUS | MINUS) term)*\r\n       *\r\n       * term => factor ((STAR factor | primary))*  // primary and factor must both not be numbers\r\n       *\r\n       * factor => MINUS? power\r\n       *\r\n       * power => primary (CARET primary)*\r\n       *\r\n       * primary => grouping\r\n       *          | environnment\r\n       *          | frac\r\n       *          | sqrt\r\n       *          | log\r\n       *          | function\r\n       *          | NUMBER\r\n       *          | VARIABLE\r\n       *\r\n       * grouping => LEFT LPAREN comp RIGHT RPAREN\r\n       *           | LPAREN comp RPAREN\r\n       *           | LBRACE comp RBRACE\r\n       *           | LEFT BAR comp RIGHT BAR\r\n       *           | BAR comp BAR\r\n       *\r\n       * environnment => matrix\r\n       *\r\n       * frac => FRAC LBRACE comp RBRACE LBRACE comp RBRACE\r\n       *\r\n       * matrix => BEGIN LBRACE MATRIX RBRACE ((comp)(AMP | DBLBACKSLASH))* END LBRACE MATRIX RBRACE\r\n       *\r\n       * sqrt => SQRT (LBRACKET comp RBRACKET)? argument\r\n       *\r\n       * log => LOG (UNDERSCORE (primary))? argument\r\n       *\r\n       * function => (SIN | COS | TAN | ...) argument\r\n       *           | OPNAME LBRACE customfunc RBRACE argument\r\n       *\r\n       * argument => grouping\r\n       *           | expr\r\n       *\r\n       * In general, each production is represented by one method (e.g. nextFactor(), nextPower()...)\r\n       *\r\n       * @param tokens A list of Tokens to be parsed.\r\n       */\r\n    constructor(tokens) {\r\n        this.tokens = tokens;\r\n        this.pos = 0;\r\n    }\r\n    /**\r\n       * Get the type that the current token matches.\r\n       * @param types A variable number of token types to match the current token\r\n       *              with.\r\n       * @returns Returns the matched token type if there is a match.\r\n       *          Otherwise returns undefined.\r\n       */\r\n    match(...types) {\r\n        const { type } = this.tokens[this.pos];\r\n        return (types.indexOf(type) !== -1) ? type : undefined;\r\n    }\r\n    /**\r\n       * Get the next token and advance the position in the token stream.\r\n       * @returns Returns the next token in the token stream.\r\n       */\r\n    nextToken() {\r\n        return this.tokens[this.pos++];\r\n    }\r\n    /**\r\n       * Get the current token in the token stream without consuming it.\r\n       * @returns Returns the current token in the token stream.\r\n       */\r\n    currentToken() {\r\n        return this.tokens[this.pos];\r\n    }\r\n    /**\r\n       * Get the previous token in the token stream. Returns undefined\r\n       * if the position is at the beginning of the stream.\r\n       * @returns Returns the previous token in the token stream.\r\n       */\r\n    previousToken() {\r\n        return this.tokens[this.pos - 1];\r\n    }\r\n    /**\r\n       * Consume the next expression in the token stream according to the following production:\r\n       *\r\n       * comp => expr ((EQUALS | NOTEQUALS | LESS | LESSEQUAL | GREATER | GREATEREQUAL) expr)*\r\n       *       | VARIABLE EQUALS EQUALS comp\r\n       * @returns Returns the root node of an expression tree.\r\n       */\r\n    nextComparison() {\r\n        let leftExpr = this.nextExpression();\r\n        // VARIABLE EQUALS comp\r\n        if (this.match(3 /* Colon */)) {\r\n            if (math.isSymbolNode(!leftExpr)) {\r\n                throw new ParseError('expected variable (SymbolNode) on left hand of assignment', this.previousToken());\r\n            }\r\n            const colon = this.nextToken();\r\n            this.tryConsume(\"Expected '=' after ':'\", 4 /* Equals */);\r\n            const rightComp = this.nextComparison();\r\n            return createMathJSNode(colon, [leftExpr, rightComp]);\r\n        }\r\n        // expr ((EQUALS | NOTEQUALS | LESS | LESSEQUAL | GREATER | GREATEREQUAL) expr)*\r\n        if (this.match(4 /* Equals */, 5 /* Notequals */, 6 /* Less */, 8 /* Lessequal */, 7 /* Greater */, 9 /* Greaterequal */)) {\r\n            // TODO: Convert this to allow chained comparisons (can't be directly done with while loop)\r\n            const operator = this.nextToken();\r\n            const rightExpr = this.nextExpression();\r\n            leftExpr = createMathJSNode(operator, [leftExpr, rightExpr]);\r\n        }\r\n        return leftExpr;\r\n    }\r\n    /**\r\n       * Consume the next expression in the token stream according to the following production:\r\n       *\r\n       * expr => term ((PLUS | MINUS) term)*\r\n       * @returns Returns the root node of an expression tree.\r\n       */\r\n    nextExpression() {\r\n        let leftTerm = this.nextTerm();\r\n        // term ((PLUS | MINUS) term)*\r\n        while (this.match(10 /* Plus */, 11 /* Minus */)) {\r\n            // build the tree with left-associativity\r\n            const operator = this.nextToken();\r\n            const rightTerm = this.nextTerm();\r\n            leftTerm = createMathJSNode(operator, [leftTerm, rightTerm]);\r\n        }\r\n        return leftTerm;\r\n    }\r\n    /**\r\n       * Consume the next term according to the following production:\r\n       *\r\n       * term => factor (((STAR | TIMES) factor) | power)*\r\n       * @returns Returns the root node of an expression tree.\r\n       */\r\n    nextTerm() {\r\n        function isNumberNode(node) {\r\n            return math.isConstantNode(node) && !Number.isNaN(Number(node));\r\n        }\r\n        let leftFactor = this.nextFactor();\r\n        let implicitMult = false;\r\n        // since bmatrix is the only environnment supported, it suffices to only have\r\n        // one token lookahead and assume that \\begin is the start of a matrix.\r\n        // However, if more environnment support is added, it would be necessary to\r\n        // have more lookahead and ensure that the matrix begins with BEGIN LBRACE MATRIX.\r\n        for (;;) {\r\n            const lookaheadType = this.match(12 /* Star */, 13 /* Times */, 14 /* Slash */, ...primaryTypes);\r\n            if (lookaheadType === undefined) {\r\n                break;\r\n            }\r\n            let operator;\r\n            let rightFactor;\r\n            // multiplication between two adjacent factors is implicit as long as\r\n            // they are not both numbers\r\n            if (isNumberNode(leftFactor) && lookaheadType === 0 /* Number */) {\r\n                throw new ParseError('multiplication is not implicit between two different'\r\n                    + 'numbers: expected * or \\\\cdot', this.currentToken());\r\n            }\r\n            else if (this.match(12 /* Star */, 13 /* Times */, 14 /* Slash */)) {\r\n                operator = this.nextToken();\r\n                rightFactor = this.nextFactor();\r\n            }\r\n            else {\r\n                const starPos = this.pos;\r\n                // implicit multiplication is only vaild if the right factor is not negated\r\n                // (2x != 2-x), so we parse a power instead of a factor\r\n                rightFactor = this.nextPower();\r\n                // multiplication is implicit: a multiplication (star) token needs to be created\r\n                operator = new Token('*', 12 /* Star */, starPos);\r\n                implicitMult = true;\r\n            }\r\n            leftFactor = createMathJSNode(operator, [leftFactor, rightFactor]);\r\n            leftFactor.implicit = implicitMult;\r\n        }\r\n        return leftFactor;\r\n    }\r\n    /**\r\n       * Consume the next factor according to the following production:\r\n       *\r\n       * factor => MINUS? power\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextFactor() {\r\n        // match for optional factor negation\r\n        if (this.match(11 /* Minus */)) {\r\n            const negate = this.nextToken();\r\n            const primary = this.nextPower();\r\n            return createMathJSNode(negate, [primary]);\r\n        }\r\n        return this.nextPower();\r\n    }\r\n    /**\r\n       * Consume the next power according to the following production:\r\n       *\r\n       * power => subscript (CARET primary)*\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextPower() {\r\n        let base = this.nextSubscript();\r\n        while (this.match(15 /* Caret */)) {\r\n            const caret = this.nextToken();\r\n            const exponent = this.nextPrimary();\r\n            base = createMathJSNode(caret, [base, exponent]);\r\n        }\r\n        return base;\r\n    }\r\n    /**\r\n       * Consume the next subscript according to the following production:\r\n       *\r\n       * subscript => primary (_ primary)*\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextSubscript() {\r\n        let base = this.nextPrimary();\r\n        while (this.match(16 /* Underscore */)) {\r\n            const underscore = this.nextToken();\r\n            let subscript;\r\n            if (this.match(53 /* Left */, 20 /* Lparen */, 18 /* Lbrace */, 24 /* Bar */)) {\r\n                subscript = this.nextGrouping();\r\n            }\r\n            else {\r\n                subscript = [this.nextPrimary()];\r\n            }\r\n            base = createMathJSNode(underscore, [base, ...subscript]);\r\n        }\r\n        return base;\r\n    }\r\n    /**\r\n       * Try to consume a token of the given type. If the next token does not match,\r\n       * an error is thrown.\r\n       * @param errMsg Error message associated with the error if the match fails.\r\n       * @param tokenTypes A variable amount of token types to match.\r\n       * @returns Returns the consumed token on successful match.\r\n       */\r\n    tryConsume(errMsg, ...tokenTypes) {\r\n        const lookaheadType = this.match(...tokenTypes);\r\n        if (lookaheadType === undefined) {\r\n            throw new ParseError(errMsg, this.currentToken());\r\n        }\r\n        return this.nextToken();\r\n    }\r\n    /**\r\n       * Consume the next primary according to the following production:\r\n       *\r\n       * primary => grouping\r\n       *          | environnment\r\n       *          | frac\r\n       *          | sqrt\r\n       *          | log\r\n       *          | function\r\n       *          | NUMBER\r\n       *          | VARIABLE\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextPrimary() {\r\n        const lookaheadType = this.match(...primaryTypes);\r\n        if (lookaheadType === undefined) {\r\n            throw new ParseError('expected primary', this.currentToken());\r\n        }\r\n        let primary;\r\n        switch (lookaheadType) {\r\n            case 53 /* Left */:\r\n            case 20 /* Lparen */:\r\n            case 18 /* Lbrace */:\r\n            case 24 /* Bar */:\r\n                // nextGrouping can return an array of children\r\n                // (if the grouping contains comma-seperated values, e.g. for a multi-value function),\r\n                // so for a primary, we only take the first value (or if there is just one, the only value)\r\n                [primary] = this.nextGrouping();\r\n                break;\r\n            case 0 /* Number */:\r\n            case 1 /* Variable */:\r\n            case 2 /* Symbol */:\r\n            case 49 /* E */:\r\n            case 56 /* T */:\r\n                primary = createMathJSNode(this.nextToken());\r\n                break;\r\n            case 29 /* Sin */:\r\n            case 30 /* Cos */:\r\n            case 31 /* Tan */:\r\n            case 32 /* Csc */:\r\n            case 33 /* Sec */:\r\n            case 34 /* Cot */:\r\n            case 35 /* Arcsin */:\r\n            case 36 /* Arccos */:\r\n            case 37 /* Arctan */:\r\n            case 38 /* Sinh */:\r\n            case 39 /* Cosh */:\r\n            case 40 /* Tanh */:\r\n            case 42 /* Ln */:\r\n            case 43 /* Exp */:\r\n            case 57 /* Det */:\r\n                primary = this.nextUnaryFunc();\r\n                break;\r\n            case 58 /* Opname */:\r\n                primary = this.nextCustomFunc();\r\n                break;\r\n            case 28 /* Frac */:\r\n                primary = this.nextFrac();\r\n                break;\r\n            case 27 /* Sqrt */:\r\n                primary = this.nextSqrt();\r\n                break;\r\n            case 41 /* Log */:\r\n                primary = this.nextLog();\r\n                break;\r\n            case 44 /* Mathrm */:\r\n                // booleans are the only currently supported mathrm tag\r\n                primary = this.nextBoolean();\r\n                break;\r\n            case 47 /* Mathbf */:\r\n                // Undefined is the only currently supported mathbf tag\r\n                primary = this.nextUndefined();\r\n                break;\r\n            case 50 /* Begin */:\r\n                // matrix is the only currently supported environnment: if more are added, another\r\n                // token of lookahead would be required to know which environnment to parse\r\n                primary = this.nextMatrix();\r\n                break;\r\n            default:\r\n                throw new ParseError('unknown token encountered during parsing', this.nextToken());\r\n        }\r\n        return primary;\r\n    }\r\n    /**\r\n       * Consume the next grouping according to the following production:\r\n       *\r\n       * grouping => LEFT LPAREN comp RIGHT RPAREN\r\n       *           | LPAREN comp RPAREN\r\n       *           | LBRACE comp RBRACE\r\n       *           | LEFT BAR comp RIGHT BAR\r\n       *           | BAR comp BAR\r\n       *           | comp\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextGrouping() {\r\n        // token indicating start of grouping\r\n        let leftRight = false; // flag indicating if grouping tokens are marked with \\left and \\right\r\n        if (this.match(53 /* Left */)) {\r\n            leftRight = true;\r\n            this.nextToken(); // consume \\left\r\n        }\r\n        const leftGrouping = this.tryConsume(\"expected '(', '|', '{'\", 20 /* Lparen */, 24 /* Bar */, 18 /* Lbrace */);\r\n        let grouping = this.nextExpression();\r\n        if (leftGrouping.type === 24 /* Bar */) {\r\n            // grouping with bars |x| also applies a function, so we create the corresponding function\r\n            // here\r\n            grouping = createMathJSNode(leftGrouping, [grouping]);\r\n        }\r\n        // a grouping can contain multiple children if the\r\n        // grouping is parenthetical and the values are comma-seperated\r\n        const children = [grouping];\r\n        if (leftGrouping.type === 20 /* Lparen */ || leftGrouping.type === 18 /* Lbrace */) {\r\n            while (this.match(17 /* Comma */)) {\r\n                this.nextToken(); // consume comma\r\n                children.push(this.nextComparison());\r\n            }\r\n        }\r\n        if (leftRight) {\r\n            this.tryConsume('expected \\\\right to match corresponding \\\\left after expression', 54 /* Right */);\r\n        }\r\n        // look for corresponding right grouping\r\n        this.tryConsumeRightGrouping(leftGrouping);\r\n        return children;\r\n    }\r\n    /**\r\n       * Consume the next token corresponding to a built-in MathJS function.\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextUnaryFunc() {\r\n        const func = this.nextToken();\r\n        const argument = this.nextArgument();\r\n        return createMathJSNode(func, argument);\r\n    }\r\n    /**\r\n       * Consume the next token corresponding to a user-defined function.\r\n       *\r\n       * customFn => OPNAME LBRACE identifier RBRACE grouping\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextCustomFunc() {\r\n        const opname = this.nextToken(); // consume \\\\operatorname\r\n        this.tryConsume(\"expected '{' after \\\\operatorname\", 18 /* Lbrace */);\r\n        const customFunc = this.nextString();\r\n        this.tryConsume(\"expected '}' after operator name\", 19 /* Rbrace */);\r\n        const argument = this.nextArgument();\r\n        return createMathJSNode(opname, [customFunc, ...argument]);\r\n    }\r\n    nextString() {\r\n        const string = [this.tryConsume('expected a letter after \\\\operatorname{', 1 /* Variable */, 2 /* Symbol */, 49 /* E */, 56 /* T */, 59 /* Eigenvalues */, 60 /* Eigenvectors */, 61 /* Cross */, 62 /* Proj */, 64 /* Norm */, 65 /* Inv */)];\r\n        while (this.match(1 /* Variable */, 2 /* Symbol */, 0 /* Number */, 49 /* E */, 56 /* T */, 59 /* Eigenvalues */, 60 /* Eigenvectors */, 61 /* Cross */, 62 /* Proj */, 64 /* Norm */, 65 /* Inv */)) {\r\n            string.push(this.nextToken());\r\n        }\r\n        return createMathJSString(string);\r\n    }\r\n    /**\r\n       * Consume the next group of arguments according to the following production:\r\n       *\r\n       * argument => grouping\r\n       *           | comp\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextArgument() {\r\n        let argument;\r\n        // try to match grouping e.g. (), {}, ||\r\n        if (this.match(53 /* Left */, 20 /* Lparen */, 18 /* Lbrace */, 24 /* Bar */)) {\r\n            // grouping around argument e.g. \\sin (x)\r\n            argument = this.nextGrouping();\r\n        }\r\n        else {\r\n            // no grouping e.g. \\sin x; consume the next token as the argument\r\n            argument = [this.nextPrimary()];\r\n        }\r\n        return argument;\r\n    }\r\n    /**\r\n       * Consume the next fraction according to the following production:\r\n       *\r\n       * frac => FRAC LBRACE comp RBRACE LBRACE comp RBRACE\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextFrac() {\r\n        const frac = this.nextToken();\r\n        this.tryConsume(\"expected '{' for the numerator in \\\\frac\", 18 /* Lbrace */);\r\n        const numerator = this.nextComparison();\r\n        this.tryConsume(\"expected '}' for the numerator in \\\\frac\", 19 /* Rbrace */);\r\n        let denominator;\r\n        // {} is optional for the denominator of \\frac\r\n        if (this.match(18 /* Lbrace */)) {\r\n            this.nextToken();\r\n            denominator = this.nextComparison();\r\n            this.tryConsume(\"expected '}' for the denominator in \\\\frac\", 19 /* Rbrace */);\r\n        }\r\n        else {\r\n            denominator = this.nextComparison();\r\n        }\r\n        return createMathJSNode(frac, [numerator, denominator]);\r\n    }\r\n    /**\r\n       * Consume the next root according to the following production:\r\n       *\r\n       * sqrt => SQRT (LBRACKET comp RBRACKET)? argument\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextSqrt() {\r\n        const sqrt = this.nextToken();\r\n        let degree = [];\r\n        if (this.match(22 /* Lbracket */)) {\r\n            this.tryConsume(\"expected '[' for the degree in \\\\sqrt\", 22 /* Lbracket */);\r\n            degree = [this.nextComparison()];\r\n            this.tryConsume(\"expected ']' for the degree in \\\\sqrt\", 23 /* Rbracket */);\r\n        }\r\n        const radicand = this.nextArgument();\r\n        return createMathJSNode(sqrt, radicand.concat(degree));\r\n    }\r\n    /**\r\n       * Consume the next log according to the following production:\r\n       *\r\n       * log => LOG (UNDERSCORE (grouping | primary))? argument\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextLog() {\r\n        const log = this.nextToken();\r\n        let degree = [];\r\n        if (this.match(16 /* Underscore */)) {\r\n            this.tryConsume(\"expected '_' for the degree in \\\\log\", 16 /* Underscore */);\r\n            degree = [this.nextPrimary()];\r\n        }\r\n        const argument = this.nextArgument();\r\n        return createMathJSNode(log, argument.concat(degree));\r\n    }\r\n    /**\r\n       * Consume the next boolean according to the following production:\r\n       *\r\n       * boolean => MATHRM LBRACE (TRUE | FALSE) RBRACE\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextBoolean() {\r\n        this.nextToken(); // consume \\mathrm\r\n        this.tryConsume(\"expected '{' after \\\\mathrm\", 18 /* Lbrace */);\r\n        const stateToken = this.tryConsume(\"expected 'True' or 'False' after '\\\\mathrm{' \"\r\n            + '(no other expressions'\r\n            + 'are supported yet)', 45 /* True */, 46 /* False */);\r\n        this.tryConsume(`expected '}' after \\\\mathrm{${stateToken.lexeme}`, 19 /* Rbrace */);\r\n        return createMathJSNode(stateToken);\r\n    }\r\n    /**\r\n       * Consume the next undefined according to the following production:\r\n       *\r\n       * undefined => MATHBF LBRACE UNDEFINED RBRACE\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextUndefined() {\r\n        this.nextToken(); // consume \\mathbf\r\n        this.tryConsume(\"expected '{' after \\\\mathbf\", 18 /* Lbrace */);\r\n        const stateToken = this.tryConsume(\"expected '?' after '\\\\mathbf{' \"\r\n            + '(no other expressions'\r\n            + 'are supported yet)', 48 /* Undefined */);\r\n        this.tryConsume(\"expected '}' after \\\\mathbf{undefined\", 19 /* Rbrace */);\r\n        return createMathJSNode(stateToken);\r\n    }\r\n    /**\r\n       * Consume the next matrix environnment according to the following production:\r\n       *\r\n       * matrix => BEGIN LBRACE MATRIX RBRACE ((comp)(AMP | DBLBACKSLASH))* END LBRACE MATRIX RBRACE\r\n       *\r\n       * @returns The root node of an expression tree.\r\n       */\r\n    nextMatrix() {\r\n        this.nextToken(); // consume \\begin\r\n        this.tryConsume(\"expected '{' after \\\\begin\", 18 /* Lbrace */);\r\n        const matrixToken = this.tryConsume(\"expected 'matrix' after '\\\\begin{' \"\r\n            + '(no other environnments'\r\n            + 'are supported yet)', 52 /* Matrix */);\r\n        this.tryConsume(\"expected '}' after \\\\begin{matrix\", 19 /* Rbrace */);\r\n        let row = [];\r\n        const rows = [];\r\n        // parse matrix elements\r\n        for (;;) {\r\n            const element = this.nextComparison();\r\n            // '&' delimits columns; append 1 element to this row\r\n            if (this.match(25 /* Amp */)) {\r\n                this.nextToken();\r\n                row.push(element);\r\n            }\r\n            else if (this.match(26 /* Dblbackslash */, 51 /* End */) !== undefined) {\r\n                // '\\\\' delimits rows; add a new row\r\n                const delimiter = this.nextToken();\r\n                row.push(element);\r\n                if (row.length === 1) {\r\n                    rows.push(element);\r\n                }\r\n                else {\r\n                    rows.push(createMathJSNode(matrixToken, row));\r\n                }\r\n                row = [];\r\n                if (delimiter.type === 51 /* End */) {\r\n                    break;\r\n                }\r\n            }\r\n            else if (this.match(55 /* Eof */)) {\r\n                throw new ParseError('unexpected EOF encountered while parsing matrix', this.currentToken());\r\n            }\r\n            else {\r\n                throw new ParseError('unexpected delimiter while parsing matrix', this.currentToken());\r\n            }\r\n        }\r\n        this.tryConsume(\"expected '{' after \\\\end\", 18 /* Lbrace */);\r\n        this.tryConsume(\"expected 'matrix' after '\\\\end{' (no other environnments\"\r\n            + 'are supported yet)', 52 /* Matrix */);\r\n        this.tryConsume(\"expected '}' after \\\\end{matrix\", 19 /* Rbrace */);\r\n        return createMathJSNode(matrixToken, rows);\r\n    }\r\n    /**\r\n       * Try to consume the right grouping token corresponding to the given left grouping token.\r\n       * e.g. '(' => ')', '{' => '}'. If the token doesn't match, an error is thrown.\r\n       *\r\n       * @param leftGroupingToken A left grouping token.\r\n       *\r\n       */\r\n    // Try to consume a right grouping character given the corresponding left grouping token\r\n    // e.g. RPAREN for LPAREN, BAR for BAR\r\n    tryConsumeRightGrouping(leftGroupingToken) {\r\n        const rightGroupingType = rightGrouping[leftGroupingToken.type];\r\n        // get any tokens that match with the required token type\r\n        const expectedLexemes = Object.keys(lexemeToType)\r\n            .filter((key) => lexemeToType[key] === rightGroupingType)\r\n            // insert quotes (e.g. { => '{')\r\n            .map((lexeme) => `'${lexeme}'`);\r\n        const errMsg = `expected ${expectedLexemes.join(' or ')} to match corresponding '${leftGroupingToken.lexeme}'`;\r\n        this.tryConsume(errMsg, rightGrouping[leftGroupingToken.type]);\r\n    }\r\n}\r\n/**\r\n * Parse an array of TeX math tokens as a MathJS expression tree.\r\n *\r\n * @param tokens An array of tokens to parse.\r\n *\r\n * @returns The root node of a MathJS expression tree.\r\n */\r\nexport default function parseTokens(tokens) {\r\n    return (new Parser(tokens)).nextComparison();\r\n}\r\n","import tokenizeTex from './tokenizeTex';\r\nimport parseTokens from './parseTokens';\r\n/**\r\n * Parse a TeX math string into a MathJS expression tree.\r\n * @returns Returns an object containing the root node of a MathJS expression tree\r\n *          and variables that need to be defined.\r\n */\r\nfunction parseTex(texStr) {\r\n    return parseTokens(tokenizeTex(texStr));\r\n}\r\n/**\r\n * Evaluate a TeX math string, returning the result as a MathJS MathType.\r\n */\r\nfunction evaluateTex(texStr, scope) {\r\n    const root = parseTex(texStr);\r\n    const evaluated = root.evaluate(scope);\r\n    return { evaluated, scope };\r\n}\r\nexport { parseTex, evaluateTex, };\r\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","lexemeToType","_","True","False","bmatrix","e","T","eigenvectors","eigenvalues","cross","proj","comp","norm","inv","lexemeToSymbol","typeToOperation","typeToMultivarOperation","constructor","lexeme","type","pos","this","isWhitespace","c","trim","isAlpha","test","isControl","isDigit","scanWord","str","end","slice","scanNumber","LexError","Error","message","args","super","name","y","__WEBPACK_EXTERNAL_MODULE_mathjs__","x","d","math","create","all","number","precision","mathImport","lastFn","lastArgs","matrix","eigs","values","vectors","a","b","divide","dot","multiply","import","override","units","Unit","UNITS","keys","forEach","unit","ParseError","token","createMathJSNode","children","_a","_b","fn","OperatorNode","FunctionNode","length","isSymbolNode","AccessorNode","IndexNode","AssignmentNode","SymbolNode","constant","Number","isNaN","ConstantNode","ArrayNode","rightGrouping","primaryTypes","Parser","tokens","match","types","indexOf","undefined","nextToken","currentToken","previousToken","nextComparison","leftExpr","nextExpression","colon","tryConsume","leftTerm","nextTerm","leftFactor","nextFactor","implicitMult","lookaheadType","operator","rightFactor","node","isConstantNode","starPos","nextPower","implicit","base","nextSubscript","nextPrimary","underscore","subscript","nextGrouping","errMsg","tokenTypes","primary","nextUnaryFunc","nextCustomFunc","nextFrac","nextSqrt","nextLog","nextBoolean","nextUndefined","nextMatrix","leftRight","leftGrouping","grouping","push","tryConsumeRightGrouping","nextArgument","opname","customFunc","nextString","string","map","join","argument","frac","numerator","denominator","sqrt","degree","concat","log","stateToken","matrixToken","row","rows","element","delimiter","leftGroupingToken","rightGroupingType","filter","parseTex","texStr","i","nextChar","command","identifier","ch","tokenizeTex","evaluateTex","scope","evaluated","evaluate"],"sourceRoot":""}