import*as e from"mathjs";var t={d:(e,n)=>{for(var s in n)t.o(n,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:n[s]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},n={};t.d(n,{b:()=>P,v:()=>E});const s={":":3,"=":4,"\\ne":5,"\\neq":5,"<":6,">":7,"\\le":8,"\\leq":8,"\\ge":9,"\\geq":9,"+":10,"-":11,"*":12,"\\cdot":12,"\\times":13,"^":15,_:16,"/":14,",":17,"{":18,"}":19,"(":20,")":21,"[":22,"]":23,"|":24,"&":25,True:45,False:46,"?":48,bmatrix:52,"\\\\":26,"\\sqrt":27,"\\frac":28,"\\sin":29,"\\cos":30,"\\tan":31,"\\csc":32,"\\sec":33,"\\cot":34,"\\arcsin":35,"\\arccos":36,"\\arctan":37,"\\sinh":38,"\\cosh":39,"\\tanh":40,"\\log":41,"\\ln":42,"\\exp":43,e:49,"\\mathrm":44,"\\mathbf":47,"\\begin":50,"\\end":51,"\\left":53,"\\right":54,T:56,"\\det":57,"\\operatorname":58,eigenvectors:60,eigenvalues:59,cross:61,proj:62,comp:63,norm:64,inv:65},r={"\\Alpha":"Alpha","\\alpha":"alpha","\\Beta":"Beta","\\beta":"beta","\\Gamma":"Gamma","\\gamma":"gamma","\\Delta":"Delta","\\delta":"delta","\\Epsilon":"Epsilon","\\epsilon":"epsilon","\\varepsilon":"varepsilon","\\Zeta":"Zeta","\\zeta":"zeta","\\Eta":"Eta","\\eta":"eta","\\Theta":"Theta","\\theta":"theta","\\vartheta":"vartheta","\\Iota":"Iota","\\iota":"iota","\\Kappa":"Kappa","\\kappa":"kappa","\\varkappa":"varkappa","\\Lambda":"Lambda","\\lambda":"lambda","\\Mu":"Mu","\\mu":"mu","\\Nu":"Nu","\\nu":"nu","\\Xi":"Xi","\\xi":"xi","\\Omicron":"Omicron","\\omicron":"omicron","\\Pi":"Pi","\\pi":"pi","\\varpi":"varpi","\\Rho":"Rho","\\rho":"rho","\\varrho":"varrho","\\Sigma":"Sigma","\\sigma":"sigma","\\varsigma":"varsigma","\\Tau":"Tau","\\tau":"tau","\\Upsilon":"Upsilon","\\upsilon":"upsilon","\\Phi":"Phi","\\phi":"phi","\\varphi":"varphi","\\Chi":"Chi","\\chi":"chi","\\Psi":"Psi","\\psi":"psi","\\Omega":"Omega","\\omega":"omega","\\ne":"!=","\\neq":"!=","\\le":"<=","\\leq":"<=","\\ge":">=","\\geq":">=","\\frac":"/","\\cdot":"*","\\i":"i","\\infty":"Infinity","\\lim":"lim"},o={4:"equal",5:"unequal",6:"smaller",7:"larger",8:"smallerEq",9:"largerEq",10:"add",11:"subtract",12:"multiply",13:"multiply",15:"pow",14:"divide",28:"divide",24:"abs",27:"sqrt",29:"sin",30:"cos",31:"tan",32:"csc",33:"sec",34:"cot",35:"asin",36:"acos",37:"atan",38:"sinh",39:"cosh",40:"tanh",41:"log10",42:"log",43:"exp",57:"det",60:"eigenvectors",59:"eigenvalues",61:"cross",62:"proj",63:"comp",64:"norm",65:"inv"},a={27:"nthRoot",41:"log"},i=class{constructor(e,t,n){this.lexeme=e,this.type=t,this.pos=n}};function c(e){return""===e.trim()}function h(e){return/^[A-Za-z]{1,1}$/.test(e)}function m(e){return/[^ -~]/.test(e)}function u(e){return e>="0"&&e<="9"}function p(e,t){if(!h(e[t]))return"";let n=t;for(;h(e[n]);)n+=1;return e.slice(t,n)}function l(e,t){if(!u(e[t]))return"";let n=t+1;for(;u(e[n]);)n+=1;if("."===e[n])for(n+=1;u(e[n]);)n+=1;return e.slice(t,n)}class x extends Error{constructor(e="",t,...n){super(...n),this.name="LexError",this.message=`at ${t}: ${e}`}}const d=(y={all:()=>e.all,create:()=>e.create},w={},t.d(w,y),w),f=(0,d.create)(d.all,{number:"BigNumber",precision:64}),g={lastFn:"",lastArgs:[],eigenvalues:e=>f.eigs(e).values,eigenvectors:e=>f.eigs(e).vectors,comp:(e,t)=>f.divide(f.dot(e,t),f.norm(e)),proj:(e,t)=>f.multiply(f.divide(e,f.norm(e)),f.divide(f.dot(e,t),f.norm(e)))};var y,w;f.import(g,{override:!0});const k=f.Unit.UNITS;Object.keys(k).forEach((e=>{delete k[e]}));const b=f;class v extends Error{constructor(e="",t,...n){super(...n),this.name="ParseError",this.message=`${t.lexeme} at ${t.pos}: ${e}`}}function T(e,t=[]){var n,s;let i=o[e.type];switch(e.type){case 4:return new b.OperatorNode("==",i,t);case 13:return new b.FunctionNode("cross",t);case 11:i=1===t.length?"unaryMinus":i;case 10:case 12:case 28:case 14:case 5:case 6:case 8:case 7:case 9:return new b.OperatorNode(null!==(n=r[e.lexeme])&&void 0!==n?n:e.lexeme,i,t);case 15:if(t.length<2)throw new v("Expected two children for ^ operator",e);return b.isSymbolNode(t[1])&&"T"===t[1].name?new b.FunctionNode("transpose",[t[0]]):new b.OperatorNode(e.lexeme,i,t);case 16:return new b.AccessorNode(t[0],new b.IndexNode(t.slice(1)));case 24:case 27:case 29:case 30:case 31:case 32:case 33:case 34:case 38:case 39:case 40:case 35:case 36:case 37:case 41:case 42:case 43:case 59:case 60:case 57:case 61:case 62:case 63:case 64:case 65:return t.length>1&&(i=null!==(s=a[e.type])&&void 0!==s?s:i),new b.FunctionNode(i,t);case 58:return new b.FunctionNode(t[0],t.slice(1));case 3:return new b.AssignmentNode(t[0],t[1]);case 1:return new b.SymbolNode(e.lexeme);case 0:{const t=Number.isNaN(Number(e.lexeme))?e.lexeme:+e.lexeme;return new b.ConstantNode(t)}case 2:return new b.SymbolNode(r[e.lexeme]);case 49:return new b.SymbolNode("e");case 45:return new b.SymbolNode("true");case 46:return new b.SymbolNode("false");case 48:return new b.SymbolNode("undefined");case 52:return new b.ArrayNode(t);case 56:return new b.SymbolNode("T");default:throw new v("unknown token type",e)}}const C={20:21,18:19,22:23,53:54,24:24},N=[53,20,18,24,0,1,2,28,27,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,57,44,47,49,50,56,58];class S{constructor(e){this.tokens=e,this.pos=0}match(...e){const{type:t}=this.tokens[this.pos];return-1!==e.indexOf(t)?t:void 0}nextToken(){return this.tokens[this.pos++]}currentToken(){return this.tokens[this.pos]}previousToken(){return this.tokens[this.pos-1]}nextComparison(){let e=this.nextExpression();if(this.match(3)){if(b.isSymbolNode(!e))throw new v("expected variable (SymbolNode) on left hand of assignment",this.previousToken());const t=this.nextToken();return this.tryConsume("Expected '=' after ':'",4),T(t,[e,this.nextComparison()])}return this.match(4,5,6,8,7,9)&&(e=T(this.nextToken(),[e,this.nextExpression()])),e}nextExpression(){let e=this.nextTerm();for(;this.match(10,11);)e=T(this.nextToken(),[e,this.nextTerm()]);return e}nextTerm(){let e=this.nextFactor(),t=!1;for(;;){const s=this.match(12,13,14,...N);if(void 0===s)break;let r,o;if(n=e,b.isConstantNode(n)&&!Number.isNaN(Number(n))&&0===s)throw new v("multiplication is not implicit between two differentnumbers: expected * or \\cdot",this.currentToken());if(this.match(12,13,14))r=this.nextToken(),o=this.nextFactor();else{const e=this.pos;o=this.nextPower(),r=new i("*",12,e),t=!0}e=T(r,[e,o]),e.implicit=t}var n;return e}nextFactor(){return this.match(11)?T(this.nextToken(),[this.nextPower()]):this.nextPower()}nextPower(){let e=this.nextSubscript();for(;this.match(15);)e=T(this.nextToken(),[e,this.nextPrimary()]);return e}nextSubscript(){let e=this.nextPrimary();for(;this.match(16);){const t=this.nextToken();let n;n=this.match(53,20,18,24)?this.nextGrouping():[this.nextPrimary()],e=T(t,[e,...n])}return e}tryConsume(e,...t){if(void 0===this.match(...t))throw new v(e,this.currentToken());return this.nextToken()}nextPrimary(){const e=this.match(...N);if(void 0===e)throw new v("expected primary",this.currentToken());let t;switch(e){case 53:case 20:case 18:case 24:[t]=this.nextGrouping();break;case 0:case 1:case 2:case 49:case 56:t=T(this.nextToken());break;case 29:case 30:case 31:case 32:case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:case 42:case 43:case 57:t=this.nextUnaryFunc();break;case 58:t=this.nextCustomFunc();break;case 28:t=this.nextFrac();break;case 27:t=this.nextSqrt();break;case 41:t=this.nextLog();break;case 44:t=this.nextBoolean();break;case 47:t=this.nextUndefined();break;case 50:t=this.nextMatrix();break;default:throw new v("unknown token encountered during parsing",this.nextToken())}return t}nextGrouping(){let e=!1;this.match(53)&&(e=!0,this.nextToken());const t=this.tryConsume("expected '(', '|', '{'",20,24,18);let n=this.nextExpression();24===t.type&&(n=T(t,[n]));const s=[n];if(20===t.type||18===t.type)for(;this.match(17);)this.nextToken(),s.push(this.nextComparison());return e&&this.tryConsume("expected \\right to match corresponding \\left after expression",54),this.tryConsumeRightGrouping(t),s}nextUnaryFunc(){return T(this.nextToken(),this.nextArgument())}nextCustomFunc(){const e=this.nextToken();this.tryConsume("expected '{' after \\operatorname",18);const t=this.nextString();return this.tryConsume("expected '}' after operator name",19),T(e,[t,...this.nextArgument()])}nextString(){const e=[this.tryConsume("expected a letter after \\operatorname{",1,2,49,56,59,60,61,62,64,65)];for(;this.match(1,2,0,49,56,59,60,61,62,64,65);)e.push(this.nextToken());return t=e,new b.SymbolNode(t.map((e=>{switch(e.type){case 1:case 0:case 49:case 56:case 59:case 60:case 61:case 62:case 64:case 65:return e.lexeme;case 2:return r[e.lexeme];default:throw new v("unknown token type",e)}})).join(""));var t}nextArgument(){let e;return e=this.match(53,20,18,24)?this.nextGrouping():[this.nextPrimary()],e}nextFrac(){const e=this.nextToken();this.tryConsume("expected '{' for the numerator in \\frac",18);const t=this.nextComparison();let n;return this.tryConsume("expected '}' for the numerator in \\frac",19),this.match(18)?(this.nextToken(),n=this.nextComparison(),this.tryConsume("expected '}' for the denominator in \\frac",19)):n=this.nextComparison(),T(e,[t,n])}nextSqrt(){const e=this.nextToken();let t=[];return this.match(22)&&(this.tryConsume("expected '[' for the degree in \\sqrt",22),t=[this.nextComparison()],this.tryConsume("expected ']' for the degree in \\sqrt",23)),T(e,this.nextArgument().concat(t))}nextLog(){const e=this.nextToken();let t=[];return this.match(16)&&(this.tryConsume("expected '_' for the degree in \\log",16),t=[this.nextPrimary()]),T(e,this.nextArgument().concat(t))}nextBoolean(){this.nextToken(),this.tryConsume("expected '{' after \\mathrm",18);const e=this.tryConsume("expected 'True' or 'False' after '\\mathrm{' (no other expressionsare supported yet)",45,46);return this.tryConsume(`expected '}' after \\mathrm{${e.lexeme}`,19),T(e)}nextUndefined(){this.nextToken(),this.tryConsume("expected '{' after \\mathbf",18);const e=this.tryConsume("expected '?' after '\\mathbf{' (no other expressionsare supported yet)",48);return this.tryConsume("expected '}' after \\mathbf{undefined",19),T(e)}nextMatrix(){this.nextToken(),this.tryConsume("expected '{' after \\begin",18);const e=this.tryConsume("expected 'matrix' after '\\begin{' (no other environnmentsare supported yet)",52);this.tryConsume("expected '}' after \\begin{matrix",19);let t=[];const n=[];for(;;){const s=this.nextComparison();if(this.match(25))this.nextToken(),t.push(s);else{if(void 0===this.match(26,51))throw this.match(55)?new v("unexpected EOF encountered while parsing matrix",this.currentToken()):new v("unexpected delimiter while parsing matrix",this.currentToken());{const r=this.nextToken();if(t.push(s),1===t.length?n.push(s):n.push(T(e,t)),t=[],51===r.type)break}}}return this.tryConsume("expected '{' after \\end",18),this.tryConsume("expected 'matrix' after '\\end{' (no other environnmentsare supported yet)",52),this.tryConsume("expected '}' after \\end{matrix",19),T(e,n)}tryConsumeRightGrouping(e){const t=C[e.type],n=`expected ${Object.keys(s).filter((e=>s[e]===t)).map((e=>`'${e}'`)).join(" or ")} to match corresponding '${e.lexeme}'`;this.tryConsume(n,C[e.type])}}function E(e){return t=function(e){let t=0;const{length:n}=e,o=[];for(;t<n;){for(;c(e[t]);)t+=1;let n="",a=55;const d=e[t];if(m(d))throw new x("invalid control sequence encountered (forgot to escape backslashes (\\begin => \\\\begin)?)",t);if(!h(d)&&d in s)a=s[d],n=d;else if("\\"===d){const o=e[t+1];if("\\"===o)a=26,n="\\\\";else if(" "===o)a=66,n="\\ ";else{const o=p(e,t+1);if(void 0===o)throw new x("expected command (a non-alphabetic character was encountered)",t);if(n=`\\${o}`,a=s[n],void 0===a&&n in r&&(a=2),void 0===a)throw new x(`unknown command "${n}"`,t)}}else if(u(d))n=l(e,t),a=0;else{if(!h(d))throw new x(`unrecognized character "${d}"`,t);{const r=p(e,t);if(r in s)n=r,a=s[r];else{const e=r[0];e in s?(n=e,a=s[e]):(n=e,a=1)}}}66!==a&&o.push(new i(n,a,t)),t+=n.length}return o.push(new i("EOF",55,t)),o}(e),new S(t).nextComparison();var t}function P(e,t){return{evaluated:E(e).evaluate(t),scope:t}}var F=n.b,q=n.v;export{F as evaluateTex,q as parseTex};
//# sourceMappingURL=index.js.map